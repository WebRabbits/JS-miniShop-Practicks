'use strict';

// ============== Работа с объектом ошибок - throw

/**
 * Отлов/поимка ошибок в JavaScript
 *
 * Отлов ошибок полезен тем, что после получения ошибки - сама программа может спокойно продолжить работать и выполнения кода НЕ БУДЕТ остановлено.
 *
 * Данные действия производятся благодаря использованию блока try{} catch(){}, который как раз таки и предоставляет возможность обработки ошибки по полученным данным, например (от пользователя (если пользователь ввёл куда-то свои данные), и так далее).
 *
 * В блоке try{} - писывается та часть кода, которая будет выполняться и возвращать какой-то предположительно положительный результат.
 *
 * ЕСЛИ ЖЕ, такого не произойдёт и возникнет ошибка в получении и обработки данных - то сработает блок catch(){}, в котором как раз можно обработать саму ошибку (например, дать какую-то информацию пользователю, либо вывести в консоль саму информацию об ошибке).
 * ТАКЖЕ, блок catch{}, поддерживает передачу круглых скобок, в которых передаётся параметр объекта ошибки. Данный объект ошибки можно назвать как угодно (например error, err или вообще e).
 * Данный объект - возвращает:
 * • Тип ошибки
 * • Название ошибки
 * • Расположение ошибки (в каком конкретном месте участке кода она произошла)
 *
 * Данный объект ошибки и информацию из него можно как раз использовать при обработки самой ошибки в блоке catch(error){}, выводя информацию о полученной ошибке.
 * ПРИ ЭТОМ, вызывать блок catch{} - можно и без круглых скобок с получением объекта ошибки.
 *
 * ВАЖНО!!! При использование данной конструкции, в момент получении ошибки - программа ВСЁ ТАКЖЕ ПРОДОЛЖИТ КОРРЕКТНО РАБОТАТЬ ДАЛЬШЕ.
 *
 * ВАЖНО!!! Конструкция try{} catch(){} - НЕ ПОДХОДИТ и НЕ БУДЕТ РАБОТАТЬ при обработке ошибок полученных в асинхронных операциях (например, таких как: setTimeout(), Promise)
 */

let data; // Определяется переменная data, в которую будет приходить некая JSON строка
try {
  data = JSON.parse('{"name":"alex}'); // В данное переменнойЮ, при помощи конструкции JSON.pars() - будет производиться преобразование полученной JSON-строки в JSON-объект.
} catch (error) {
  data = { name: 'unknown' }; // В переменную data будет помещаться объект по умолчанию, если в блоке try{} возникнет ошибки при парсинге значения из строки в объект
  console.error('Не получилось распарсить JSON', error); // Будет выведена ошибка в консоль с данным текстом и указанием (типа, имени, места) где произошла ошибка
}

// ЕСЛИ, в блоке try{} парсинг строки в объект будет выполнен корректно - то именно эта полученная информация в виде полученного объекта и выведется в консоль.
// ИНАЧЕ, если в блоке try{}, преобразование данных из строки в объект будет невозможным (например, придётся некорректная строка, по формату которой НЕЛЬЗЯ будет преобразовать данные в JSON-объект) - ТО возникнет ошибка, которая как рази будет обработана в блоке catch(error){} и информация по ней будет выведена в консоль.
// ПРИ ЭТОМ, код, находящийся ВНЕ БЛОКА КОНСТРУКЦИИ try{} catch(){} - ВСЁ РАВНО БУДЕТ ВЫПОЛНЕН.

console.log(data);
console.log('Ещё один консоль лог №1'); // Данный код будет выполнен ВСЕГДА!

// ============== Ещё одна генерация и отлов ошибок в блоке try{} catch(){}

try {
  document.querySelector('button').innerText - 'Нажми на меня';
} catch (error) {
  console.dir(error);
}

console.log('Ещё один консоль лог №2');

// ============== Пример НЕ РАБОТАЮЩЕЙ КОНСТРУКЦИИ try{} catch(){} при обработки асинхронной операции с setTimeout()

/**
 * В данном примере, также обрабатывается некорректный JSON-объект, у которого парсинг с JSON-строки произошёл некорректно.
 * ПРИ ЭТОМ, мы всё также получаем обычную ошибку, вида:
 * VM252:1 Uncaught SyntaxError: Unterminated string in JSON at position 18 (line 1 column 19)
    at JSON.parse (<anonymous>)
    at index.js:58:22

    НО НЕ ПОЛУЧАЕМ ошибку с нашим кастомным текстом, вида: 'Ошибка не работает!'... и далее уже ошибка из объекта ошибки error.

    ТО ЕСТЬ, код ведёт себя так, как будто блока try{} catch(){} - вообще НЕ СУЩЕСТВУЕТ.
    • Сперва отрабатывает console.log('Ещё один консоль лог №3');
    • Далее отрабатывает функция setTimeout()
    • И уже где-то внутри функции setTimeout() при обработки и парсинге JSON в объект - возникает сама ошибка.
 */

// try {
//   setTimeout(() => {
//     console.log(JSON.parse('{"name":"John Doe}'));
//   }, 0);
// } catch (error) {
//   console.log('Ошибка не работает!', error);
// }

// console.log('Ещё один консоль лог №3');

// ============== Пример обработки ошибки, полученной в функции с обработкой Promise, который обёрнут конструкцией try{} catch(){}

//  В данном примере, также как и в примере с setTimeout(), наглядно видно, что:
// В самом Promise и при его обработки действительно где-то возникла ошибка.
// ОДНАКО, обёрнутый вызов функции func() в блоке try{} catch(){} - ТАКЖЕ НЕ ПРИВОДИТ к корректной обработки ошибки.
// Сама кастомная назначенная ошибка из блока catch(){} - НЕ ВЫВОДИТСЯ в консоль, а само приложение и весь синхронный код ПРОДОЛЖАЕТ работать дальше.

function func() {
  return new Promise((resolve, reject) => {
    reject('Ошибка в Promise');
  });
}

try {
  func();
} catch (error) {
  console.log('Ошибка обработки Promise', error);
}

console.log('Ещё один консоль лог №4');

// ============== Генерация ошибки при их последующем получении и обработки

// Генерация ошибки может производится несколькими способами при помощи операторов:
// • throw (выбрасывать) - позволяет обозначить ошибку в коду, которая может произойти в том или ином случаи (например, когда в функцию передан не правильный тип данных который ожидался).
// ПРИ ЭТОМ, в консоль будет выводиться ТОЛЬКО ПЕРЕДАННЫЙ ТЕКСТ ОШИБКИ записанной в операторе throw.
// Данный оператор при установки/описании ошибки - НЕ ВЫВЕДЕТ ИНФОРМАЦИИ  о типе/имени/месте возникновения ошибки.
// НАПРИМЕР: 'B - не число'
// • throw Error('текст ошибки') - позволяет вывести в консоль полученную ошибку, которая будет содержать как заданное кастомное описание самой ошибки, и также тип ошибки.
// НАПРИМЕР: Error: B - не число
//     at calculate (index.js:121:11)
//     at index.js:127:15
// • throw new Error('текст ошибки') - полностью является аналогичной записью формата вызова ошибки throw Error()

function calculate(a, b) {
  if (typeof a !== 'number') {
    throw new Error('A - не число');
  }

  if (typeof b !== 'number') {
    throw new Error('B - не число');
  }
  return a + b ** 2 / 3;
}

try {
  console.log(calculate(5, false));
} catch (error) {
  console.error(error);
} finally {
  console.log('Код выполняется всегда, даже при получении ошибки');
}

console.log('Ещё один консоль лог №5');
